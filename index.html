<!DOCTYPE html>
<html class="no-js" lang="en">
<head>

    <!--- basic page needs
    ================================================== -->
    <meta charset="utf-8">
    <title>Algorithms 2 - Visualizing Triangulations</title>
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- mobile specific metas
    ================================================== -->
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- CSS
    ================================================== -->
    <link rel="stylesheet" href="css/base.css">
    <link rel="stylesheet" href="css/vendor.css">
    <link rel="stylesheet" href="css/main.css">

    <!-- script
    ================================================== -->
    <script src="js/modernizr.js"></script>

    <!-- favicons
    ================================================== -->
    <link rel="shortcut icon" href="favicon.png" type="image/x-icon">
    <link rel="icon" href="favicon.png" type="image/x-icon">
    <!-- <link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
    <link rel="icon" href="favicon.ico" type="image/x-icon"> -->

</head>


<body id="top">
    
    <!-- preloader
    ================================================== -->
    <div id="preloader">
        <div id="loader" class="dots-jump">
            <div></div>
            <div></div>
            <div></div>
        </div>
    </div>

    <!-- header
    ================================================== -->



    <!-- home
    ================================================== -->
<!--     <section id="home" class="s-home page-hero target-section" data-parallax="scroll" data-image-src="images/hero-bg.jpg" data-natural-width=3000 data-natural-height=2000 data-position-y=center>-->
         <section id="home" class="s-home page-hero target-section topfix" data-parallax="scroll" data-image-src="images/MATH_BG.jpg" data-natural-width=3000 data-natural-height=2000 data-position-y=center>

        <div class="grid-overlay">
            <div></div>
        </div>

        <div class="home-content">

            <div class="row home-content__main">

                <h1>
                Visualizing Triangulation Algorithms
                </h1>

                <h3>
                Homer Gamil & Royce Schultz
                </h3>

                <div class="home-content__video">
<!--                     <a class="video-link" href="https://player.vimeo.com/video/117310401?color=01aef0&title=0&byline=0&portrait=0" data-lity>
                        <span class="video-icon"></span>
                        <span class="video-text">Watch Video</span>
                    </a> -->
                </div>

                <div class="home-content__button">
<!--                     <a href="#about" class="smoothscroll btn btn--primary btn--large">
                        More About Us
                    </a>
                    <a href="#contact" class="smoothscroll btn btn--large">
                        Let's Talk
                    </a> -->
                </div>

            </div> <!-- end home-content__main -->

        </div> <!-- end home-content -->

    </section> <!-- end s-home --> 


    <!-- about
    ================================================== -->
    <section id="about" class="s-about target-section">

        <div class="row section-header bit-narrow" data-aos="fade-up">
            <div class="col-full">
                <h1 class="display-1">
                Introduction
                </h1>
            </div>
        </div> <!-- end section-header -->

        <div class="row bit-narrow" data-aos="fade-up">
            <div class="col-full">
                <p class="lead">
                    A triangulation of a set of points is created by drawing non-intersecting line segments between points until no more lines can be added. Each face in the resulting graph is a triangle. Triangulation graphs have applications in <a href="https://en.wikipedia.org/wiki/Point_location">point location</a> algorithms as well as computer graphics meshing.
                </p>
                <p class="lead">
                    This project covers triangulation algorithms for both simple polygons and arbitrary point clouds.
                </p>
            </div>
        </div> <!-- end about-desc -->

    </section> <!-- end s-about -->


    <!-- ALGO A
    ================================================== -->
    <section id='services' class="s-services target-section darker">

        <div class="row section-header bit-narrow" data-aos="fade-up">
            <div class="col-full">
                <h1 class="display-1">
                    Quadratic Triangulation of a Polygon
                </h1>
            </div>
        </div>

        <div class="row bit-narrow" data-aos="fade-up">
            <div class="col-full">
                <h3 class="subhead">Definitions</h3>
                <p class="lead">
                    A diagonal is a line segment connecting two points.
                </p>
                <p class="lead">
                    An ear is a diagonal between 2 points that share a common neighbor. That is, 2 consecutive edges of the polygon compose 2 edges of the created triangle. Every polygon has at least 2, non-overlapping ears. A convex polygon of n points contains n ears.
                </p>
            </div>
        </div> <!-- end about-desc -->

        <div class="row bit-narrow" data-aos="fade-up">
            <div class="col-full">
                <h3 class="subhead">Algorithm Summary</h3>
                <p class="lead">
                    This method uses a linear time method to find a diagonal. The discovered diagonal partitions the polygon into 2 halves. This is repeated recursively on both halves until only 3 points remain, the base case. In the best case when the diagonal evenly partitions the points of the polygon, the algorithm runs in O(nlog(n)) time in much the same way Quicksort operates. In the worst case, the diagonal only clips an ear and the algorithm runs in O(n<sup>2</sup>) time.
                </p>
                <h3 class="subhead">Analysis</h3>
                <p class="lead">
                    In the best case the algorithm runs as, T(n) = n + 2T(<sup>n</sup>&frasl;<sub>2</sub>) = O(nlog(n)).
                    <br>
                    But in the worst case the algorithm runs as T(n) = n + T(1) + T(n-1) = O(n<sup>2</sup>).
                </p>
            </div>
        </div> <!-- end about-desc -->

        <div class="video-container">
            <iframe width="560" height="315" src="https://www.youtube.com/embed/6rS8l3J59yc" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
        </div>

        <div class="row bit-narrow" data-aos="fade-up">
            <div class="col-full">
                <h3 class="subhead">An Iterative Improvement</h3>
                <p class="lead">
                    Independent recursion such as the previous algorithm is useful in multi-processing environments, but when run as a single-threaded process it is an inefficient use of memory as each function call is stored on the call stack with partial information of the solution. The memory usage can be reduced by using an iterative approach.
                    <br>
                    Instead of recursing on both sides, pick just 1 side. On this side, find the middle point relative to the discovered diagonal. Find a second diagonal containing this point, also in linear time. The larger side of this second diagonal will always contain the edge of the first diagonal. This side is the bad-sub-polygon because it contains 2 diagonal edges. The other, smaller side is the good-sub-polygon and contains only 1 diagonal edge. Because every polygon contains at least 2 non-overlapping ears, at least 1 ear of the good-sub-polygon is also an ear of the greater polygon.
                    <br>
                    Repeat this process until the good-sub-polygon contains only 3 points. Notice, the good-sub-polygon contains less than half the points on the selected side of the partition. This form of recursion forms a geometric series. Thus, an ear is found in O(n) time.
                </p>
                <p class="lead">
                    To triangulate a polygon of n points, n ears must be clipped. Therefore, triangulation by this method run in O(n) time.
                </p>
            </div>
        </div> <!-- end about-desc -->
    </section> <!-- end s-services -->


    <!-- ALGO B -->
    <section id="about" class="s-about target-section">

        <div class="row section-header bit-narrow" data-aos="fade-up">
            <div class="col-full">
                <h1 class="display-1">
                    Improved triangulation: O(nlogn)
                </h1>
            </div>
        </div> <!-- end section-header -->

        <div class="row bit-narrow" data-aos="fade-up">
            <div class="col-full">
                <h3 class="subhead">Algorithm Summary</h3>
                <p class="lead">
                    This method uses a scan-line approach to first preprocess a polygon into monotone sub-polygons. A monotone polygon has 2 halves, a right and left side. The points on each side are strictly increasing or decreasing along the y-axis. Once decomposed into monotone sub-polygons, each sub-polygon can be triangulated in O(n) time. [Not shown in this project]
                </p>
                <p class="lead">
                    The algorithm has 2 components: Edge memory and vertex classification. As the scan-line moves down, maintain a BST containing all edges intersecting the scan-line. The value of each edge in the BST is the x-coordinate of the intersection with the scan-line. This is unique because the value changes as the scan-line moves, however this maintenance is done in constant time because while the BST value may change, the order of the lines will not, by the definition of simple polygon. Additionally, maintain a helper for each edge. The helper is the most recent point above the scanline that is horizontally visible from the given edge in the tree.
                    <br>
                    Each point is classified into 1 of 5 categories. Diagonals are added depending on the classification of the point and the helper of the edge to the point's left.
                    <br>
                </p>
                <!-- TODO: Fix this image -->
                <img src="images/improved_triangulation.jpeg" alt="Improved Triangulation">
                <!-- <img src="https://imgur.com/a/K33KxRb" /> -->
                <h3 class="subhead">Analysis</h3>
                <p class="lead">
                    A scanline approach considers points in order by y-coordinate. To achieve this, the points must be sorted, so immediately the algorithm runs in Ω(nlogn).
                </p>
            </div>
        </div> <!-- end about-desc -->

        <div class="video-container">
            <iframe width="560" height="315" src="https://www.youtube.com/embed/R5_BmFx_KJs" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
        </div>

        <div class="video-container">
        <iframe height="500"
        src="https://www.youtube.com/embed/-OFzpoj61U0?autoplay=1&loop=1&playlist=-OFzpoj61U0&autoplay=1">
        <!-- https://www.youtube.com/watch?v=HKjNhDppq6Q -->
        </iframe>
        </div>
        
        <!-- TODO: Fix this video, for some reason it gets over written with a later video -->
        <!-- <div class="video-container">
            <iframe width="560" height="315" src="https://www.youtube.com/embed/-OFzpoj61U0" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
        </div> -->
    </section>


    <!-- ALGO D -->
    <section id="about" class="s-about target-section">

        <div class="row section-header bit-narrow" data-aos="fade-up">
            <div class="col-full">
                <h1 class="display-1">
                Delaunay Triangulation
                </h1>
            </div>
        </div> <!-- end section-header -->

        <div class="row bit-narrow" data-aos="fade-up">
            <div class="col-full">
                <p class="lead">
                    In this section we present a simple incremental algorithm that constructs the Delaunay Triangulation. The Delaunay triangulation (or else Delone) can be defined as a triangulation method such that given a set of vertices V, after applying a triangulation transformation DT(V), no vertex lies inside the circumcircle of any triangle (besides the vertices that form that triangle). The objective of this technique is to maximize the minimum angle between all the angles of the existing triangles. As a result, we obtain a structure that does not frequently contain triangles with extremely acute angles.
                </p>
                <p class="lead">
                    The input of the algorithm is a set of points (nodes) V = {v<sub>1</sub>,v<sub>2</sub>,...v<sub>n</sub>}. The idea of the algorithm is to incrementally insert new points one after another and update our structure every round. It is also important to point out that this method always maintains  a Deulaunay triangulation at any given point in time.  
                </p>
                <p class ="lead">
                    This algorithm does not only build the triangulation, but also provides a point-location data structure for the final triangulation. It can also be used to generate a Voronoi diagram, which is the dual graph of a Delaunay triangulation.
                </p>

                <h3 class="subhead">Applications</h3>
                <p class="lead">
                    Delaunay triangulation methods are often used in applications where mesh generation is utilized. One topic is finite element analysis which makes use of the finite element and the finite volume methods.
                </p>
                <h3 class="subhead">Algorithm</h3>

                <p class="lead">
                    The algorithm can be described as follows: 
                </p>
                <p class="lead">
                    We are given a set of vertices  V={v<sub>1</sub>,v<sub>2</sub>,...,v<sub>n</sub>}. Since the proposed algorithm is an incremental method, it implies that vertices will be added into space one after another. 

                </p>
                <p class="lead">
                    Before we begin with our vertex insertion process, we need to ensure that all our vertices in the vertex set S are contained within one large triangle. This temporary triangle is necessary to exist as the whole process is based on the idea that every newly added vertex should fall within some existing triangle. To satisfy this condition, we add 3 temporary vertices which form a triangle that encloses all the vertices of V. After our triangulation process is concluded for all the vertices of V, the temporary vertices and consequently the edges that connect to them will be removed.
                </p>
                <p class="lead">
                    After we generate the temporary triangle, we begin our process by arbitrarily inserting a new vertex V<sub>k</sub> in space every round.  The next step is to find the triangle Δabc that contains V<sub>k</sub>. After we identify the triangle Δabc, we draw edges from each vertex (a,b,c) that connect to V<sub>k</sub> {a,V<sub>k</sub>}, {b,V<sub>k</sub>}, {c,V<sub>k</sub>}. This consequently creates 3 sub-triangles ΔabV<sub>k</sub>, ΔacV<sub>k</sub>, ΔbcV<sub>k</sub>. 
                </p>
                <p class="lead">
                    Now, for each new triangle we need to check the vertex of the triangle that lies on the opposite side of the edge that does not contain V<sub>k</sub>. To elaborate, assume that our triangle is Δv<sub>1</sub>v<sub>2</sub>V<sub>k</sub>. We need to identify the vertex d, that is on the opposite side of {v<sub>1</sub>,v<sub>2</sub>} That does not include V<sub>k</sub>. If such a vertex d does not exist, this implies that our edge {v<sub>1</sub>,v<sub>2</sub>} falls on the convex hull. In this case we do nothing. If however we do identify a vertex V<sub>d</sub>, then we need to follow the process below: 
                </p>
                <p class="lead">
                    If V<sub>d</sub> is within the circumcircle of Δv<sub>1</sub>v<sub>2</sub>V<sub>k</sub>, then we remove {v<sub>1</sub>,v<sub>2</sub>}, and connect V<sub>k</sub>,V<sub>d</sub> with {V<sub>k</sub>,V<sub>d</sub>}. In addition, we recursively repeat the same process, this time with triangles ΔV<sub>k</sub>v<sub>1</sub>V<sub>d</sub>, and ΔV<sub>k</sub>v<sub>2</sub>,V<sub>d</sub>.  
                </p>

                <h3 class="subhead">Pseudocode</h3>
                <p class="lead">
                    <xmp class="lead">
                    Triangulation(v) {
                        Identify triangle Δabc that contains Vk
                        Connect Vk with a,b,c adding {Vk,a}, {Vk,b},{Vk,c}
                        Opposite_vertex_test(Vk,a,b)
                        Opposite_vertex_test(Vk,a,c)
                        Opposite_vertex_test(Vk,b,c)
                    }

                    Opposite_vertex_test(Vk,v1,v2){
                        If {v1,v2} falls on the convex hull:
                            end function
                        Else:
                            Find vertex d that is on the opposite side of Vk in terms of {v1,v2} 
                            (in between of d and Vk falls the edge {v1,v2}
                            If d falls within the circumcircle of the triangle ΔVk,v1,v2:
                                Remove edge {v1,v2}
                                Add edge {Vk,v2}
                                Opposite_vertex_test(Vk,v1,d)
                                Opposite_vertex_test(Vk,v2,d)
                    }
                    </xmp>

                </p>

                <h3 class="subhead">Runtime</h3>
                <p class ="lead">
                    This algorithm does not only build the triangulation, but also provides a point-location data structure for the final triangulation. It can also be used to generate a Voronoi diagram, which is the dual graph of a Delaunay triangulation.
                    <ul class="lead">
                        <li class="lead">The runtime for all the changes we make regarding the structure of the triangulation are O(1) </li>
                        <li class="lead">The runtime required to determine the triangle in which the newly added vertex falls into is O(logn)</li>
                    </ul>
                </p>

            </div>
        </div> <!-- end about-desc -->
        
        <div class="row bit-narrow" data-aos="fade-up">
        <div class="col-full">
        <h3 class="subhead">Demo 1</h3>
        <p class="lead">
                    The demonstration below indicates how the proposed algorithm runs on a micro-level. The video shows all the operations and comparisons that are performed during 1 iteration. The demo was programmed in python using the matplotlib library.
                </p>
        </div>
        </div>
        <div class="video-container">
        <iframe height="500"
        src="https://www.youtube.com/embed/HKjNhDppq6Q?autoplay=1&loop=1&playlist=HKjNhDppq6Q&autoplay=1">
        <!-- https://www.youtube.com/watch?v=HKjNhDppq6Q -->
        </iframe>
        </div>

        <div class="row bit-narrow" data-aos="fade-up">
        <div class="col-full">
        <h3 class="subhead">Demo 2</h3>
        <p class="lead">
                    The demonstration below indicates how the proposed algorithm runs on a macro-level. The video indicates how a triangulation would look like from the beginning till the end of the algorithm. The blue dashed lines represent the connections made with the "big temporary triangle points". The temporary points cannot be observed in the scene as they are placed outside of our bounds to create a triangle that covers all the vertices of our set. In the final stage when the triangulation is complete the temporary vertices are removed, and so are the edges that connect with them, consequently creating our final structure. The demo was programmed in python using the matplotlib library.
                </p>
        </div>
        </div>
        <div class="video-container">
        <iframe height="500"
        src="https://www.youtube.com/embed/Im8zJCkIyoA?autoplay=1&loop=1&playlist=Im8zJCkIyoA&autoplay=1">
        <!-- https://www.youtube.com/watch?v=Im8zJCkIyoA -->
        </iframe>
        </div>

    </section> <!-- end s-about -->

    <!-- ALGO D -->
    <section id="about" class="s-about target-section">

        <div class="row section-header bit-narrow" data-aos="fade-up">
            <div class="col-full">
                <h1 class="display-1">
                Triangulating k-guardable polygons
                </h1>
            </div>
        </div> <!-- end section-header -->

        <div class="row bit-narrow" data-aos="fade-up">
            <div class="col-full">
                <p class="lead">
                    In this section we provide 2 algorithms that triangulate k-guardable polygons in O(kn) time. An object is determined to be k-guardable if its boundary can be observed by k points which we call “guards”. The first algorithm that we provide requires the guards as an input to the problem, while the second algorithm does not require it as an input. 
                </p>
                <h3 class="subhead">Preliminaries</h3>
                <p class="lead">
                    Before we begin to describe the two algorithms in detail, it is important to provide some necessary definitions related to the problem:  
                </p>
                <p class ="lead">
                    Star-shaped Polygon - A star-shaped polygon can be defined as a polygonal shape that contains a region that is able to see the entire shape. We call the set of points that fall in this region a kernel.
                </p>


                <p class ="lead">
                    Weakly edge visible polygon - A polygon is defined as weakly edge-visible if it contains an edge {p,q} subset of boundary of P, such that every point p of P can see some part of the edge {p,q}. 

                </p>

                <p class ="lead">
                    Visibility polygon - VP(p,G) - The visibility polygon of a point p that belongs to P, is the set of points in P that are visible from p. The complexity of a visibility polygon is O(n)
                </p>

                <p class ="lead">
                    Edge-Visibility Polygon - EVP(e,P) - The edge visibility polygon of an edge e and a polygon P, describes a set of p belonging in P that are visible from at least one point of our edge e. 
                </p>

                <p class ="lead">
                    Extended Edge-Visibility Polygon - EEVP(e,P) - An extended edge visibility polygon is an extension of the EVP. It is defined as the smallest pure subpolygon of P that contains the edge visibility polygon. 
                </p>

                <p class ="lead">
                    Geodesic Path - The geodesic between 2 points p<sub>1</sub>,p<sub>2</sub> in P is the shortest polygonal path contained in P that connects them.
                </p>

                <p class ="lead">
                    Vertical Extension - vert(v) - A vertical extension of a vertex v is the maximal vertical line segment which is contained in the interior of P, and intersects v 
                </p>

                <p class ="lead">
                    Vertical Decomposition - T(P)- A vertical decomposition (trapezoidal decomposition) of P is generated by adding a vertical extension to each vertex of P.
                </p>

                <h3 class="subhead">Problem Definition</h3>
                <p class="lead">
                    We denote P as the simple polygon that contains n vertices. We call a polygon k-guardable if there exists a set G of k points in P called guards such that every point that belongs to the boundary of P can see at least one point in G
                </p>

                <h3 class="subhead">Algorithm without Guard Set input</h3>

                <p class="lead">
                    This algorithm shows how we can triangulate a k-guardable polygon in O(kn) time without having any knowledge about the guard set. As it appears, the most complex procedure of this algorithm is the computation of the VP in linear time, and consequently the EEVP (in linear time as well). We consider the following:
                </p>
                <p class ="lead">
                    <ul class="lead">
                        <li class="lead"> Given a vertex x of polygon P and a point y on the edge {v,w} of P, then if y sees x, the geodesic between x and v is a convex chain and entirely visible from y. It can also be computed in O(n) time. 
                        </li>

                        <li class="lead">A weakly edge-visible polygon can be triangulated in linear time
                        </li>
                        <li>
                            The EVP can be computed in O(n) time
                        </li>
                        <li>
                            An EEVP can also be computed and triangulated in O(n) time
                        </li>
                    </ul>
                </p>

                <p class="lead">
                    The objective with this algorithm is to make use of the linear-time triangulation on EEVPs to obtain a triangulation for the whole polygon P. When an EEVP is computed, we obtain windows of new pockets. These are generated by the diagonals of P that are on the boundary of the corresponding EEVP. Using each new window, in a recursive way we compute a new VP, and then we triangulate it within that pocket. This happens until we triangulate all of P.                     
                </p>

                <p class="lead">
                    It is important to note that the recursion depth will always be equivalent to the order of the number of guards that are required to guard the boundary of P. Furthermore, to keep track of all the windows and their respective polygons we implement a queue, which is used in the algorithm, as it provides the elements in the order in which they were added. 
                </p>

                <p class="lead">
                    Lastly, we observe that the EEVPs that are created by the algorithm develop a tree structure. This tree structure will have at most 3k levels which implies that the main loop of the algorithm will require at most 3k iterations. Since there are no relations between the nodes of the tree, every level can be processed in O(n) time. Consequently, we get an overall runtime of O(kn).
                </p>


                <h3 class="subhead">Pseudocode</h3>
                <p class="lead">
                    A pseudocode for the described algorithm is provided below:
                </p>
                <p class="lead">
                    <xmp class="lead">
                    For every edge w of P do:
                        
                        Pick the next (w,P) from S (wi,Pi) and remove it from S
                        Compute and triangulate the EEVP of (wi,Pi)
                        Add the resulting edges of the triangulation to our P
                        For every edge wj of EEVP(wi,Pi) do:
                            If it is boundary and diagonal of P then:
                                Determine Qj as the untriangulated region of P. 
                                (The boundary of Qj is enclosed by wj and the boundary of P)
                                Add (wj,Qj) to S
                    Return P
                    </xmp>

                </p>


                <h3 class="subhead">Algorithm with Guard Set input</h3>

                <p class="lead">
                    In this algorithm an input set that contains k guards is provided as an input. The triangulation time is still O(kn). A difference between the previous algorithm is that it does not compute the edge visibility polygon, therefore a significant amount of complexity is avoided. We consider the following: 
                </p>
                <p class ="lead">
                    <ul class="lead">
                        <li class="lead">The vertical projection onto w can be computed in O(|Pw|) time
                        </li>

                        <li class="lead">The vertical decomposition of a star-shaped polygon P can be computed in O(n) time
                        </li>
                    </ul>
                </p>
                <p class="lead">
                    The most complex part of the algorithm is to determine the visibility polygon of a point. The algorithm determines the vertical decomposition of P in O(kn) time. To elaborate, it computes all the vertical extensions of P that are crossing the visibility polygon of a guard. This happens in O(n), so for k guards overall would give us O(kn). 

                </p>
                <p class="lead">
                    Afterwards, since we have the vertical decomposition of P, finding the triangulation of P is a simple task. The algorithm is described in pseudo code below: 
                </p>


                <h3 class="subhead">Pseudocode</h3>
                <p class="lead">
                    <xmp class="lead">
                    For every guard g that belongs in the Guard set do:

                        Find the visibility polygon VP1
                        For every window w in VP1 do:

                            Determine the vertical projection onto w 
                            Add the Steiner points to w
                        (From this process we obtain a simple polygon VP2)
                        Compute the vertical decomposition of VP2
                        For every vertex v in VP2 do:

                            If it is not a steiner point added in the previous step then:
                                Add the vertical extension of v to the boundary of VP2
                        (From the previous process we obtain a polygon VP3)
                        For every vertex v in VP3 do:

                            Determine the endpoints of vert(v) on the boundary of P
                    </xmp>

                </p>

                <h3 class="subhead">Illustration</h3>


                <p class="lead">
                    <img src="images/with_guards_illustration.png" alt="With Guard Set Algorithm">
                </p>

                <p class="lead">
                    The illustration above provides an execution sample of the described algorithm (Process evolves from left to right). The right square represents our guard point. The grayed area represents the visibility polygon generated from our square guard point.The black circles either indicate a corner or a position of a vertical extension of it, and the white ones new Steiner points.
                </p>

                <!-- <h3 class="subhead">Runtime information</h3>
                <p class ="lead">
                    <ul class="lead">
                        <li class="lead">The vertical projection onto w can be computed in O (| P w |) time.
                        </li>

                        <li class="lead">The vertical decomposition of a star-shaped polygon P is correctly computed by the above algorithm in O ( n) time.
                        </li>
                    </ul>
                </p> -->

            </div>
        </div> <!-- end about-desc -->

<!--         <div class="video-container">
        <iframe height="500"
        src="https://www.youtube.com/embed/GRonxog5mbw?autoplay=1&loop=1&playlist=GRonxog5mbw&autoplay=1">
        </iframe> -->

    </section> <!-- end s-about -->
    <!-- REFERENCES
    ================================================== -->
    <section id='services' class="s-services target-section darker">
        <div class="row section-header bit-narrow" data-aos="fade-up">
            <div class="col-full">
                <h1 class="display-1">
                Code Repositories
                </h1>
            </div>
        </div>


        <div class="row bit-narrow" data-aos="fade-up">
            <div class="col-full">
                <p class ="lead">
                    <a href="https://github.com/royceschultz/AlgoAnimationProject">Polygon Triangulation Algorithms</a> 
                </p>
                <p class ="lead">
                    <a href="https://github.com/HomerG/CS6043-FP">Delaunay Triangulation</a> 
                </p>
            </div>
        </div> <!-- end about-desc -->



        <div class="row section-header bit-narrow" data-aos="fade-up">
            <div class="col-full">
                <h1 class="display-1">
                References
                </h1>
            </div>
        </div>
        <div class="row bit-narrow" data-aos="fade-up">
            <div class="col-full">
                <p class ="lead">
                    <ul class="lead">
                        <li class="lead">Aloupis, Greg, et al. “Triangulating and Guarding Realistic Polygons.” Computational Geometry, vol. 47, no. 2, 2014, pp. 296–306., https://doi.org/10.1016/j.comgeo.2013.03.005. 
                        </li>

                        <li class="lead">“Bowyer–Watson Algorithm.” Wikipedia, Wikimedia Foundation, 11 Dec. 2020, https://en.wikipedia.org/wiki/Bowyer%E2%80%93Watson_algorithm. 
                        </li>
                        <li class="lead">““Chapter 7 - Delaunay Triangulation: Incremental Construction.” Delaunay Triangulation: Incremental Construction, https://ti.inf.ethz.ch/ew/courses/CG13/lecture/Chapter%209.pdf. 
                        </li>
                        <li class="lead">“Chapter9 Voronoidiagrams - Ti.inf.ethz.ch.” Voronoi Diagrams, https://ti.inf.ethz.ch/ew/courses/CG13/lecture/Chapter%209.pdf. 
                        </li>
                        <li class="lead">CMSC 754: Lecture 12 Delaunay Triangulations: General Properties - UMD. https://www.cs.umd.edu/class/spring2020/cmsc754/Lects/lect12-delaun-prop.pdf. 
                        </li>
                        <li class="lead">CMSC 754: Lecture 13 Delaunay Triangulations: Incremental ... - Cs.umd.edu. https://www.cs.umd.edu/class/spring2020/cmsc754/Lects/lect13-delaun-alg.pdf?tdsourcetag=s_pctim_aiomsg. 
                        </li>
                        <li class="lead">“Delaunay Triangulation.” Wikipedia, Wikimedia Foundation, 12 May 2022, https://en.wikipedia.org/wiki/Delaunay_triangulation. 
                        </li>
                    </ul>
                </p>
            </div>
        </div> <!-- end about-desc -->

    </section> <!-- end s-services -->

  
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="animations.js"></script>



    <!-- testimonies
    ================================================== -->
    <section class="s-testimonials">

        <!-- <div class="testimonials__icon" data-aos="fade-up"></div> -->
        
        <div class="row section-header bit-narrow aos-init aos-animate" data-aos="fade-up">
            <div class="col-full">
                <!-- <h3 class="subhead">What we do</h3> -->
                <h1 class="display-1">
                
                </h1>
            </div>
        </div>

<!--         <div class="row testimonials narrow">

            <div class="col-full testimonials__slider" data-aos="fade-up">

                <div class="testimonials__slide">
                    <p>Qui ipsam temporibus quisquam vel. Maiores eos cumque distinctio nam accusantium ipsum. 
                    Laudantium quia consequatur molestias delectus culpa facere hic dolores aperiam. Accusantium quos qui praesentium corpori.</p>
                    <div class="testimonials__author">
                        Tim Cook
                        <span>CEO, Apple</span>
                    </div>
                </div> <!-- end testimonials__slide 

                <div class="testimonials__slide">
                    <p>Excepturi nam cupiditate culpa doloremque deleniti repellat. Veniam quos repellat voluptas animi adipisci.
                    Nisi eaque consequatur. Quasi voluptas eius distinctio. Atque eos maxime. Qui ipsam temporibus quisquam vel.</p>
                    <div class="testimonials__author">
                        Sundar Pichai
                        <span>CEO, Google</span>
                    </div>
                </div> <!-- end testimonials__slide 

                <div class="testimonials__slide">
                    <p>Repellat dignissimos libero. Qui sed at corrupti expedita voluptas odit. Nihil ea quia nesciunt. Ducimus aut sed ipsam.  
                    Autem eaque officia cum exercitationem sunt voluptatum accusamus. Quasi voluptas eius distinctio.</p>
                    <div class="testimonials__author">
                        Satya Nadella
                        <span>CEO, Microsoft</span>
                    </div>
                </div> <!-- end testimonials__slide 
                
            </div> <!-- end testimonials__slider 

        </div> <!-- end testimonials 

    </section> <!-- end s-testimonials -->


    <!-- contact
    ================================================== -->
<!--     <section id="contact" class="s-contact target-section">

            <div class="grid-overlay">
                <div></div>
            </div>

        <div class="row section-header narrow" data-aos="fade-up">
            <div class="col-full">
                <h3 class="subhead">Keep In Touch</h3>
                <h1 class="display-1">Feel free to contact us for any <br> project idea or collaboration</h1>
            </div>
        </div> <!-- end section-header -->

<!--         <div class="row contact-main" data-aos="fade-up">
            <div class="col-full">
                <p class="contact-email">
                    <a href="mailto:#0">sayhello@sublime.com</a>
                </p>
                <p class="contact-address">
                1600 Amphitheatre Parkway <br>
                Mountain View, CA, 94043 US 
                </p>
                <p class="contact-numbers">
                +1 (917) 123 456 &nbsp; +1 (917) 333 987
                </p>

                <ul class="contact-social">
                    <li>
                        <a href="#0"><i class="fab fa-facebook"></i></a>
                    </li>
                    <li>
                        <a href="#0"><i class="fab fa-twitter"></i></a>
                    </li>
                    <li>
                        <a href="#0"><i class="fab fa-instagram"></i></a>
                    </li>
                    <li>
                        <a href="#0"><i class="fab fa-behance"></i></a>
                    </li>
                    <li>
                        <a href="#0"><i class="fab fa-dribbble"></i></a>
                    </li>
                </ul>
            </div>
        </div> -->

    </section> <!-- end s-contact --> 


    <!-- footer
    ================================================== -->
    <footer>
        <div class="row">
<!--             <div class="col-full ss-copyright">
                <span>© Copyright Sublime 2018</span> 
                <span>Design by <a href="https://www.styleshout.com/">Styleshout</a></span>
            </div> -->
        </div>

<!--         <div class="ss-go-top">
            <a class="smoothscroll" title="Back to Top" href="#top">Back to Top</a>
        </div> -->
    </footer>


    <!-- photoswipe background
    ================================================== -->
    <div aria-hidden="true" class="pswp" role="dialog" tabindex="-1">

        <div class="pswp__bg"></div>
        <div class="pswp__scroll-wrap">

            <div class="pswp__container">
                <div class="pswp__item"></div>
                <div class="pswp__item"></div>
                <div class="pswp__item"></div>
            </div>

            <div class="pswp__ui pswp__ui--hidden">
                <div class="pswp__top-bar">
                    <div class="pswp__counter"></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button> <button class="pswp__button pswp__button--share" title=
                    "Share"></button> <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button> <button class="pswp__button pswp__button--zoom" title=
                    "Zoom in/out"></button>
                    <div class="pswp__preloader">
                        <div class="pswp__preloader__icn">
                            <div class="pswp__preloader__cut">
                                <div class="pswp__preloader__donut"></div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                    <div class="pswp__share-tooltip"></div>
                </div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button> <button class="pswp__button pswp__button--arrow--right" title=
                "Next (arrow right)"></button>
                <div class="pswp__caption">
                    <div class="pswp__caption__center"></div>
                </div>
            </div>

        </div>

    </div> <!-- end photoSwipe background -->
<!--     <div>
    <svg id="svg" viewBox="0 0 200 200" preserveAspectRatio="xMidYMid meet">
      <defs>
        <linearGradient id="maskGradient" x1="0" y1="0" x2="1" y2="0" spreadMethod="pad">
          <stop stop-color="#000000" stop-opacity="0" offset="0%"></stop>
          <stop stop-color="#71237c" stop-opacity="0.25" offset="93.5%"></stop>
          <stop stop-color="#c22dd5" stop-opacity="0.6" offset="94.5%"></stop>
          <stop stop-color="#d68adf" stop-opacity="0.85" offset="95%"></stop>
          <stop stop-color="#c22dd5" stop-opacity="0.6" offset="95.5%"></stop>
          <stop stop-color="#000000" stop-opacity="0" offset="96.5%"></stop>
        </linearGradient>
      </defs>
      <g id="scanline">
        <rect id="revealMaskRect" x="-15%" y="-100%" width="15%" height="300%" fill="url(#maskGradient)"></rect>
      </g>
      <g id="triangles"></g>
      <g id="points"></g>
    </svg>
    </div> -->


    <!-- Java Script
    ================================================== -->
    <script src="js/jquery-3.2.1.min.js"></script>
    <script src="js/plugins.js"></script>
    <script src="js/main.js"></script>

</body>
